// Prisma uses this connection string from your .env
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Permission {
  id          String @id @default(cuid())
  /// machine key like "products:read"
  key         String @unique
  description String

  roles RolePermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Role {
  id String @id @default(cuid())

  /// null = global template role (optional); non-null = tenant-scoped role
  tenantId String?
  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  name        String // e.g. "OWNER", "Catalog Editor"
  description String?
  isSystem    Boolean @default(false) // seed defaults can mark true

  // permissions
  permissions RolePermission[]

  // reverse relation to memberships
  memberships UserTenantMembership[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, name]) // one role name per tenant
  @@index([tenantId])
}

/// ----- NEW: join table role<->permission -----
model RolePermission {
  roleId       String
  permissionId String

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([permissionId])
}

/// A tenant/company
model Tenant {
  id         String @id @default(cuid())
  tenantSlug String @unique
  tenantName String

  memberships UserTenantMembership[]
  products    Product[]
  branding    TenantBranding?        @relation("TenantToBranding")

  roles Role[]

  branches              Branch[]
  userBranchMemberships UserBranchMembership[]
  productStocks         ProductStock[]
  stockLots             StockLot[]
  stockLedgers          StockLedger[]

  // Back-relation for AuditEvent. One tenant -> many audit events.
  auditEvents AuditEvent[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum StockMovementKind {
  RECEIPT // +qty into a new (or existing) lot
  ADJUSTMENT // +/- qty (e.g., audit correction)
  CONSUMPTION // -qty to fulfill/consume (e.g., order)
  REVERSAL // reverse a prior ledger movement
}

model Branch {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  branchSlug String
  branchName String
  isActive   Boolean @default(true)

  // Relations
  memberships   UserBranchMembership[]
  productStocks ProductStock[]
  stockLots     StockLot[]
  stockLedgers  StockLedger[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, branchSlug]) // unique slug per tenant
  @@index([tenantId])
  @@index([tenantId, branchName])
}

model UserBranchMembership {
  id String @id @default(cuid())

  userId   String
  tenantId String
  branchId String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, branchId]) // one membership per user/branch
  @@index([tenantId])
  @@index([userId])
  @@index([branchId])
}

model ProductStock {
  id String @id @default(cuid())

  tenantId  String
  branchId  String
  productId String

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch  Branch  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  qtyOnHand    Int @default(0) // sum of lot qtyRemaining
  qtyAllocated Int @default(0) // reserved for orders (future)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, branchId, productId])
  @@index([branchId])
  @@index([productId])
}

model StockLot {
  id String @id @default(cuid())

  tenantId  String
  branchId  String
  productId String

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch  Branch  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  qtyReceived  Int
  qtyRemaining Int

  /// Unit cost stored in **pence** (GBP minor units)
  unitCostPence Int?
  sourceRef     String? // PO/transfer ref (future)
  receivedAt    DateTime @default(now())

  ledgerEntries StockLedger[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId, branchId, productId, receivedAt]) // FIFO scan
  @@index([branchId, productId])
}

model StockLedger {
  id String @id @default(cuid())

  tenantId  String
  branchId  String
  productId String
  lotId     String?

  tenant  Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch  Branch    @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product Product   @relation(fields: [productId], references: [id], onDelete: Restrict)
  lot     StockLot? @relation(fields: [lotId], references: [id], onDelete: SetNull)

  kind        StockMovementKind
  qtyDelta    Int // + for RECEIPT/adjust-up; - for CONSUMPTION/adjust-down
  reason      String? // free text
  actorUserId String?
  actorUser   User?             @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  occurredAt DateTime @default(now())
  createdAt  DateTime @default(now())

  @@index([tenantId, branchId, productId, occurredAt])
  @@index([kind])
}

/// A person that can belong to multiple tenants
model User {
  id                 String @id @default(cuid())
  userEmailAddress   String @unique
  userHashedPassword String

  memberships UserTenantMembership[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branchMemberships UserBranchMembership[]
  stockLedgerEvents StockLedger[]

  // Back-relation for AuditEvent where this user is the actor.
  auditEvents AuditEvent[]

  @@index([createdAt])
  @@index([updatedAt])
}

/// Join table: which user belongs to which tenant, with role
model UserTenantMembership {
  id       String @id @default(cuid())
  userId   String
  tenantId String

  // NEW: future source of truth
  roleId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  role   Role   @relation(fields: [roleId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, tenantId], name: "userId_tenantId")
  @@index([roleId])
}

/// A product owned by a tenant (POC scope)
model Product {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  productName       String
  productSku        String
  /// Product price stored in **pence** (GBP minor units)
  productPricePence Int

  entityVersion Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  stocks       ProductStock[]
  stockLots    StockLot[]
  stockLedgers StockLedger[]

  @@unique([tenantId, productSku])
  @@index([tenantId])
  @@index([createdAt])
  @@index([updatedAt])
}

/// Stores idempotency for POST/PUT so we can replay the same result for duplicate requests
model IdempotencyRecord {
  id                 String   @id @default(cuid())
  idempotencyKey     String   @unique
  requestFingerprint String // e.g., stable hash of method+path+body+user+tenant
  storedResponseJson Json
  expiresAt          DateTime
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([expiresAt])
}

model TenantBranding {
  /// One row per tenant
  tenantId String @id
  tenant   Tenant @relation("TenantToBranding", fields: [tenantId], references: [id], onDelete: Cascade)

  /// Optional preset key (one of the frontend keys)
  presetKey String?

  /// Theme overrides exactly as your frontend builds them (JSON)
  /// { primaryColor?, primaryShade?, colors?, defaultRadius?, fontFamily? }
  overridesJson Json?

  /// Optional logo URL
  logoUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ApiRequestLog {
  id String @id @default(cuid())

  // Who
  tenantId String?
  userId   String?

  // Request
  method    String
  path      String
  routeKey  String? // e.g. "GET /api/products/:productId"
  query     String?
  ip        String?
  userAgent String?

  // Response
  statusCode    Int
  durationMs    Int
  errorCode     String?
  correlationId String?

  // Bodies (truncated/masked by middleware)
  reqBody String?
  resBody String?

  createdAt DateTime @default(now())

  @@index([tenantId, createdAt])
  @@index([userId, createdAt])
  @@index([routeKey, createdAt])
  @@index([statusCode, createdAt])
  @@index([correlationId])
}

// --- Enums ---
enum AuditEntityType {
  PRODUCT
  BRANCH
  STOCK_LOT
  STOCK_LEDGER
  PRODUCT_STOCK
  USER
  ROLE
  TENANT
  TENANT_BRANDING 
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  STOCK_RECEIVE
  STOCK_ADJUST
  STOCK_CONSUME
  ROLE_ASSIGN
  ROLE_REVOKE
  LOGIN
  LOGOUT
  THEME_UPDATE 
  THEME_LOGO_UPDATE 
}

// --- Append-only audit log ---
model AuditEvent {
  id String @id @default(cuid())

  // Multi-tenant + actor
  tenantId    String
  tenant      Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  actorUserId String?
  actorUser   User?   @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  // What changed
  entityType AuditEntityType
  entityId   String
  action     AuditAction

  // Optional display name (denormalized for faster lists)
  entityName String? // e.g. productName, branchName at time of event

  // State snapshots (whitelisted JSON shapes)
  beforeJson Json?
  afterJson  Json?
  diffJson   Json? // compact patch-style diff

  // Request context
  correlationId String?
  ip            String?
  userAgent     String?

  createdAt DateTime @default(now())

  @@index([tenantId, entityType, entityId, createdAt])
  @@index([actorUserId, createdAt])
  @@index([action, createdAt])
  @@index([correlationId])
}
