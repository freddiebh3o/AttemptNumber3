// Prisma uses this connection string from your .env
datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
  extensions        = [vector]
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

model Permission {
  id          String @id @default(cuid())
  /// machine key like "products:read"
  key         String @unique
  description String

  roles RolePermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Role {
  id String @id @default(cuid())

  /// null = global template role (optional); non-null = tenant-scoped role
  tenantId String?
  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  name        String // e.g. "OWNER", "Catalog Editor"
  description String?
  isSystem    Boolean @default(false) // seed defaults can mark true

  // archival (soft delete)
  isArchived       Boolean   @default(false)
  archivedAt       DateTime?
  archivedByUserId String?

  // permissions
  permissions RolePermission[]

  // reverse relation to memberships
  memberships UserTenantMembership[]

  // approval levels
  approvalLevels  TransferApprovalLevel[]  @relation("ApprovalLevelRequiredRole")
  approvalRecords TransferApprovalRecord[] @relation("ApprovalRecordRequiredRole")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, name]) // one role name per tenant
  @@index([tenantId])
  @@index([tenantId, isArchived])
}

/// ----- NEW: join table role<->permission -----
model RolePermission {
  roleId       String
  permissionId String

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([permissionId])
}

/// A tenant/company
model Tenant {
  id         String @id @default(cuid())
  tenantSlug String @unique
  tenantName String

  /// Feature flags for per-tenant feature control
  /// Example: {"barcodeScanningEnabled": false, "barcodeScanningMode": null}
  featureFlags Json?

  memberships UserTenantMembership[]
  products    Product[]
  branding    TenantBranding?        @relation("TenantToBranding")

  roles Role[]

  branches              Branch[]
  userBranchMemberships UserBranchMembership[]
  productStocks         ProductStock[]
  stockLots             StockLot[]
  stockLedgers          StockLedger[]
  stockTransfers        StockTransfer[]
  transferTemplates     StockTransferTemplate[]
  transferApprovalRules TransferApprovalRule[]
  transferMetrics       TransferMetrics[]
  transferRouteMetrics  TransferRouteMetrics[]

  // Back-relation for AuditEvent. One tenant -> many audit events.
  auditEvents AuditEvent[]

  // Chat conversations for this tenant
  chatConversations ChatConversation[]

  // Chat analytics for this tenant
  chatAnalytics ChatAnalytics[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum StockMovementKind {
  RECEIPT // +qty into a new (or existing) lot
  ADJUSTMENT // +/- qty (e.g., audit correction)
  CONSUMPTION // -qty to fulfill/consume (e.g., order)
  REVERSAL // reverse a prior ledger movement
}

enum StockTransferStatus {
  REQUESTED
  APPROVED
  REJECTED
  IN_TRANSIT
  PARTIALLY_RECEIVED
  COMPLETED
  CANCELLED
}

enum TransferPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum TransferInitiationType {
  PUSH // Source branch initiates (sends stock to destination)
  PULL // Destination branch initiates (requests stock from source)
}

enum ApprovalRuleConditionType {
  TOTAL_QTY_THRESHOLD // Total quantity > X
  TOTAL_VALUE_THRESHOLD // Total value (pence) > X
  SOURCE_BRANCH // Specific source branch
  DESTINATION_BRANCH // Specific destination branch
  PRODUCT_CATEGORY // Product has category X (future)
}

enum ApprovalMode {
  SEQUENTIAL // Must approve in order
  PARALLEL // All can approve simultaneously
  HYBRID // Level 1 first, then 2+ parallel
}

enum ApprovalStatus {
  PENDING // Awaiting approval
  APPROVED // Approved
  REJECTED // Rejected
  SKIPPED // Not required (rule didn't match)
}

model Branch {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  branchSlug String
  branchName String
  isActive   Boolean @default(true)

  /// Soft delete fields
  isArchived       Boolean   @default(false)
  archivedAt       DateTime?
  archivedByUserId String?

  // Relations
  memberships               UserBranchMembership[]
  productStocks             ProductStock[]
  stockLots                 StockLot[]
  stockLedgers              StockLedger[]
  transfersAsSource         StockTransfer[]             @relation("TransferSource")
  transfersAsDestination    StockTransfer[]             @relation("TransferDestination")
  templateAsSource          StockTransferTemplate[]     @relation("TemplateSource")
  templateAsDestination     StockTransferTemplate[]     @relation("TemplateDestination")
  approvalConditions        TransferApprovalCondition[]
  routeMetricsAsSource      TransferRouteMetrics[]      @relation("RouteMetricsSource")
  routeMetricsAsDestination TransferRouteMetrics[]      @relation("RouteMetricsDestination")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, branchSlug]) // unique slug per tenant
  @@index([tenantId])
  @@index([tenantId, branchName])
  @@index([tenantId, isArchived])
}

model UserBranchMembership {
  id String @id @default(cuid())

  userId   String
  tenantId String
  branchId String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, branchId]) // one membership per user/branch
  @@index([tenantId])
  @@index([userId])
  @@index([branchId])
}

model ProductStock {
  id String @id @default(cuid())

  tenantId  String
  branchId  String
  productId String

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch  Branch  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  qtyOnHand    Int @default(0) // sum of lot qtyRemaining
  qtyAllocated Int @default(0) // reserved for orders (future)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, branchId, productId])
  @@index([branchId])
  @@index([productId])
}

model StockLot {
  id String @id @default(cuid())

  tenantId  String
  branchId  String
  productId String

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch  Branch  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  qtyReceived  Int
  qtyRemaining Int

  /// Unit cost stored in **pence** (GBP minor units)
  unitCostPence Int?
  sourceRef     String? // PO/transfer ref (future)
  receivedAt    DateTime @default(now())

  ledgerEntries StockLedger[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId, branchId, productId, receivedAt]) // FIFO scan
  @@index([branchId, productId])
}

model StockLedger {
  id String @id @default(cuid())

  tenantId  String
  branchId  String
  productId String
  lotId     String?

  tenant  Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch  Branch    @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product Product   @relation(fields: [productId], references: [id], onDelete: Restrict)
  lot     StockLot? @relation(fields: [lotId], references: [id], onDelete: SetNull)

  kind        StockMovementKind
  qtyDelta    Int // + for RECEIPT/adjust-up; - for CONSUMPTION/adjust-down
  reason      String? // free text
  actorUserId String?
  actorUser   User?             @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  occurredAt DateTime @default(now())
  createdAt  DateTime @default(now())

  @@index([tenantId, branchId, productId, occurredAt])
  @@index([kind])
}

/// A person that can belong to multiple tenants
model User {
  id                 String @id @default(cuid())
  userEmailAddress   String @unique
  userHashedPassword String

  memberships UserTenantMembership[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branchMemberships         UserBranchMembership[]
  stockLedgerEvents         StockLedger[]
  transfersRequested        StockTransfer[]          @relation("TransferRequester")
  transfersReviewed         StockTransfer[]          @relation("TransferReviewer")
  transfersShipped          StockTransfer[]          @relation("TransferShipper")
  transferTemplatesCreated  StockTransferTemplate[]
  transferTemplatesArchived StockTransferTemplate[]  @relation("TemplateArchivedBy")
  approvalLevelsAsRequired  TransferApprovalLevel[]  @relation("ApprovalLevelRequiredUser")
  approvalRecordsAsRequired TransferApprovalRecord[] @relation("ApprovalRecordRequiredUser")
  approvalRecordsAsApprover TransferApprovalRecord[] @relation("ApprovalRecordApprover")

  // Back-relation for AuditEvent where this user is the actor.
  auditEvents AuditEvent[]

  // Chat conversations created by this user
  chatConversations ChatConversation[]

  @@index([createdAt])
  @@index([updatedAt])
}

/// Join table: which user belongs to which tenant, with role
model UserTenantMembership {
  id       String @id @default(cuid())
  userId   String
  tenantId String

  // NEW: future source of truth
  roleId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  role   Role   @relation(fields: [roleId], references: [id])

  /// Soft delete fields
  isArchived       Boolean   @default(false)
  archivedAt       DateTime?
  archivedByUserId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, tenantId], name: "userId_tenantId")
  @@index([roleId])
  @@index([tenantId, isArchived])
}

/// A product owned by a tenant (POC scope)
model Product {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  productName       String
  productSku        String
  /// Product price stored in **pence** (GBP minor units)
  productPricePence Int

  /// Barcode value (EAN-13, UPC-A, Code128, QR)
  barcode     String?
  /// Barcode format type (EAN13, UPCA, CODE128, QR)
  barcodeType String?

  /// Soft delete fields
  isArchived       Boolean   @default(false)
  archivedAt       DateTime?
  archivedByUserId String?

  entityVersion Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  stocks                ProductStock[]
  stockLots             StockLot[]
  stockLedgers          StockLedger[]
  transferItems         StockTransferItem[]
  transferTemplateItems StockTransferTemplateItem[]

  @@unique([tenantId, productSku])
  @@unique([tenantId, barcode])
  @@index([tenantId])
  @@index([barcode])
  @@index([createdAt])
  @@index([updatedAt])
}

/// Inter-branch stock transfer workflow
model StockTransfer {
  id             String @id @default(cuid())
  tenantId       String
  transferNumber String // Auto-generated (e.g., "TRF-2025-001")

  // Branches
  sourceBranchId      String
  destinationBranchId String

  // Workflow
  status         StockTransferStatus     @default(REQUESTED)
  priority       TransferPriority        @default(NORMAL)
  initiationType TransferInitiationType  @default(PUSH)

  // Actors
  requestedByUserId   String  // User who initiated request
  reviewedByUserId    String? // User who approved/rejected
  shippedByUserId     String? // User who shipped
  initiatedByBranchId String? // Branch that initiated the transfer (PUSH: source, PULL: destination)

  // Timestamps
  requestedAt DateTime  @default(now())
  reviewedAt  DateTime?
  shippedAt   DateTime?
  completedAt DateTime?

  // Notes
  requestNotes String? @db.Text
  reviewNotes  String? @db.Text // Reason for rejection
  orderNotes   String? @db.Text // Order notes for communication

  // Delivery planning
  expectedDeliveryDate DateTime?

  // Reversal fields
  isReversal           Boolean @default(false) // True if this is a reversal transfer
  reversalOfId         String? // Links to original transfer (if reversal)
  reversedByTransferId String? // Bidirectional link to reversal transfer (if reversed)
  reversalReason       String? @db.Text // Why reversal occurred

  // Multi-level approval
  requiresMultiLevelApproval Boolean @default(false)

  // Relations
  tenant            Tenant                   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sourceBranch      Branch                   @relation("TransferSource", fields: [sourceBranchId], references: [id], onDelete: Restrict)
  destinationBranch Branch                   @relation("TransferDestination", fields: [destinationBranchId], references: [id], onDelete: Restrict)
  requestedByUser   User                     @relation("TransferRequester", fields: [requestedByUserId], references: [id], onDelete: Restrict)
  reviewedByUser    User?                    @relation("TransferReviewer", fields: [reviewedByUserId], references: [id], onDelete: SetNull)
  shippedByUser     User?                    @relation("TransferShipper", fields: [shippedByUserId], references: [id], onDelete: SetNull)
  items             StockTransferItem[]
  reversalOf        StockTransfer?           @relation("TransferReversal", fields: [reversalOfId], references: [id], onDelete: SetNull)
  reversals         StockTransfer[]          @relation("TransferReversal")
  reversedBy        StockTransfer?           @relation("TransferReversedBy", fields: [reversedByTransferId], references: [id], onDelete: SetNull)
  reversedOriginals StockTransfer[]          @relation("TransferReversedBy")
  approvalRecords   TransferApprovalRecord[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, transferNumber])
  @@unique([reversalOfId])
  @@index([tenantId, status, priority, requestedAt])
  @@index([sourceBranchId, status])
  @@index([destinationBranchId, status])
  @@index([requestedByUserId])
  @@index([reversedByTransferId])
  @@index([expectedDeliveryDate])
  @@index([tenantId, initiationType])
  @@index([initiatedByBranchId])
}

/// Line items for stock transfer
model StockTransferItem {
  id         String @id @default(cuid())
  transferId String
  productId  String

  // Quantities
  qtyRequested Int // Initial quantity requested
  qtyApproved  Int? // May differ from requested (partial approval)
  qtyShipped   Int  @default(0) // Actual qty shipped (may be less than approved)
  qtyReceived  Int  @default(0) // Actual qty received (incremental)

  // Cost tracking (populated on ship)
  lotsConsumed     Json? // Array of {lotId, qty, unitCostPence}
  avgUnitCostPence Int? // Weighted average cost of shipped items

  // Partial shipment tracking
  shipmentBatches Json? // Array of {batchNumber, qty, shippedAt, shippedByUserId, lotsConsumed}

  // Relations
  transfer StockTransfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  product  Product       @relation(fields: [productId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([transferId, productId])
  @@index([productId])
}

/// Stock transfer templates for saving common transfer configurations
model StockTransferTemplate {
  id          String  @id @default(cuid())
  tenantId    String
  name        String // "Weekly Retail Restock"
  description String? @db.Text

  sourceBranchId      String
  destinationBranchId String

  createdByUserId String

  // Archival (soft delete)
  isArchived       Boolean   @default(false)
  archivedAt       DateTime?
  archivedByUserId String?

  // Relations
  tenant            Tenant                      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sourceBranch      Branch                      @relation("TemplateSource", fields: [sourceBranchId], references: [id], onDelete: Cascade)
  destinationBranch Branch                      @relation("TemplateDestination", fields: [destinationBranchId], references: [id], onDelete: Cascade)
  createdByUser     User                        @relation(fields: [createdByUserId], references: [id], onDelete: Restrict)
  archivedByUser    User?                       @relation("TemplateArchivedBy", fields: [archivedByUserId], references: [id], onDelete: Restrict)
  items             StockTransferTemplateItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([sourceBranchId])
  @@index([destinationBranchId])
  @@index([createdByUserId])
  @@index([tenantId, isArchived])
}

/// Line items for stock transfer templates
model StockTransferTemplateItem {
  id         String @id @default(cuid())
  templateId String
  productId  String
  defaultQty Int // Default quantity for this product

  // Relations
  template StockTransferTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  product  Product               @relation(fields: [productId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([templateId, productId])
  @@index([productId])
}

/// Transfer approval rules for multi-level approval workflow
model TransferApprovalRule {
  id           String       @id @default(cuid())
  tenantId     String
  name         String // "High-Value Transfer Approval"
  description  String?      @db.Text
  isActive     Boolean      @default(true)
  approvalMode ApprovalMode @default(SEQUENTIAL)
  priority     Int          @default(0) // Higher priority rules evaluated first

  /// Soft delete fields
  isArchived       Boolean   @default(false)
  archivedAt       DateTime?
  archivedByUserId String?

  // Relations
  tenant     Tenant                      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  conditions TransferApprovalCondition[]
  levels     TransferApprovalLevel[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId, isActive])
  @@index([tenantId, priority])
  @@index([tenantId, isArchived])
}

/// Conditions that trigger an approval rule
model TransferApprovalCondition {
  id            String                    @id @default(cuid())
  ruleId        String
  conditionType ApprovalRuleConditionType
  threshold     Int? // For QTY/VALUE thresholds
  branchId      String? // For branch conditions (source or destination based on conditionType)

  // Relations
  rule   TransferApprovalRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  branch Branch?              @relation(fields: [branchId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ruleId])
  @@index([branchId])
}

/// Approval levels required by a rule
model TransferApprovalLevel {
  id             String  @id @default(cuid())
  ruleId         String
  level          Int // 1, 2, 3, etc.
  name           String // "Manager", "Director", "Finance"
  requiredRoleId String? // Specific role required (e.g., OWNER)
  requiredUserId String? // Specific user required (e.g., Finance Director)

  // Relations
  rule TransferApprovalRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  role Role?                @relation("ApprovalLevelRequiredRole", fields: [requiredRoleId], references: [id], onDelete: SetNull)
  user User?                @relation("ApprovalLevelRequiredUser", fields: [requiredUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([ruleId, level])
  @@index([ruleId])
  @@index([requiredRoleId])
  @@index([requiredUserId])
}

/// Records approval status for each level of a transfer
model TransferApprovalRecord {
  id               String         @id @default(cuid())
  transferId       String
  level            Int // Which approval level this is
  levelName        String // "Manager", "Director", etc.
  status           ApprovalStatus @default(PENDING)
  requiredRoleId   String? // Role required for this approval
  requiredUserId   String? // User required for this approval
  approvedByUserId String? // Who actually approved
  approvedAt       DateTime?
  notes            String?        @db.Text

  // Relations
  transfer       StockTransfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  requiredRole   Role?         @relation("ApprovalRecordRequiredRole", fields: [requiredRoleId], references: [id], onDelete: SetNull)
  requiredUser   User?         @relation("ApprovalRecordRequiredUser", fields: [requiredUserId], references: [id], onDelete: SetNull)
  approvedByUser User?         @relation("ApprovalRecordApprover", fields: [approvedByUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([transferId, level])
  @@index([status])
  @@index([requiredRoleId])
  @@index([requiredUserId])
  @@index([approvedByUserId])
}

/// Stores idempotency for POST/PUT so we can replay the same result for duplicate requests
model IdempotencyRecord {
  id                 String   @id @default(cuid())
  idempotencyKey     String   @unique
  requestFingerprint String // e.g., stable hash of method+path+body+user+tenant
  storedResponseJson Json
  expiresAt          DateTime
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([expiresAt])
}

model TenantBranding {
  /// One row per tenant
  tenantId String @id
  tenant   Tenant @relation("TenantToBranding", fields: [tenantId], references: [id], onDelete: Cascade)

  /// Optional preset key (one of the frontend keys)
  presetKey String?

  /// Theme overrides exactly as your frontend builds them (JSON)
  /// { primaryColor?, primaryShade?, colors?, defaultRadius?, fontFamily? }
  overridesJson Json?

  /// Optional logo URL
  logoUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ApiRequestLog {
  id String @id @default(cuid())

  // Who
  tenantId String?
  userId   String?

  // Request
  method    String
  path      String
  routeKey  String? // e.g. "GET /api/products/:productId"
  query     String?
  ip        String?
  userAgent String?

  // Response
  statusCode    Int
  durationMs    Int
  errorCode     String?
  correlationId String?

  // Bodies (truncated/masked by middleware)
  reqBody String?
  resBody String?

  createdAt DateTime @default(now())

  @@index([tenantId, createdAt])
  @@index([userId, createdAt])
  @@index([routeKey, createdAt])
  @@index([statusCode, createdAt])
  @@index([correlationId])
}

/// Pre-computed transfer metrics for analytics dashboard
model TransferMetrics {
  id         String   @id @default(cuid())
  tenantId   String
  metricDate DateTime @db.Date

  // Volume metrics (count of transfers by status on this date)
  transfersCreated   Int @default(0)
  transfersApproved  Int @default(0)
  transfersShipped   Int @default(0)
  transfersCompleted Int @default(0)
  transfersRejected  Int @default(0)
  transfersCancelled Int @default(0)

  // Timing metrics (average duration in seconds for each workflow stage)
  avgApprovalTime Int? // REQUESTED → APPROVED
  avgShipTime     Int? // APPROVED → IN_TRANSIT
  avgReceiveTime  Int? // IN_TRANSIT → COMPLETED
  avgTotalTime    Int? // REQUESTED → COMPLETED

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, metricDate])
  @@index([tenantId, metricDate])
}

/// Pre-computed route metrics for branch dependency analysis
model TransferRouteMetrics {
  id                  String   @id @default(cuid())
  tenantId            String
  sourceBranchId      String
  destinationBranchId String
  metricDate          DateTime @db.Date

  // Volume metrics per route
  transferCount     Int  @default(0)
  totalUnits        Int  @default(0)
  avgCompletionTime Int? // Average seconds from REQUESTED → COMPLETED

  // Relations
  tenant            Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sourceBranch      Branch @relation("RouteMetricsSource", fields: [sourceBranchId], references: [id], onDelete: Cascade)
  destinationBranch Branch @relation("RouteMetricsDestination", fields: [destinationBranchId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, sourceBranchId, destinationBranchId, metricDate])
  @@index([tenantId, metricDate])
}

// --- Enums ---
enum AuditEntityType {
  PRODUCT
  BRANCH
  STOCK_LOT
  STOCK_LEDGER
  PRODUCT_STOCK
  USER
  ROLE
  TENANT
  TENANT_BRANDING
  STOCK_TRANSFER
  STOCK_TRANSFER_ITEM
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  STOCK_RECEIVE
  STOCK_ADJUST
  STOCK_CONSUME
  STOCK_REVERSE // Lot restoration (reversal ledger entry)
  ROLE_ASSIGN
  ROLE_REVOKE
  LOGIN
  LOGOUT
  THEME_UPDATE
  THEME_LOGO_UPDATE
  TRANSFER_REQUEST
  TRANSFER_APPROVE
  TRANSFER_REJECT
  TRANSFER_SHIP
  TRANSFER_RECEIVE
  TRANSFER_CANCEL
  TRANSFER_REVERSE
  TRANSFER_APPROVE_LEVEL // Multi-level approval submission
  TRANSFER_PRIORITY_CHANGE // Priority updated
  TRANSFER_SHIP_PARTIAL // Partial shipment
  APPROVAL_RULE_CREATE
  APPROVAL_RULE_UPDATE
  APPROVAL_RULE_DELETE
}

// --- Append-only audit log ---
model AuditEvent {
  id String @id @default(cuid())

  // Multi-tenant + actor
  tenantId    String
  tenant      Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  actorUserId String?
  actorUser   User?   @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  // What changed
  entityType AuditEntityType
  entityId   String
  action     AuditAction

  // Optional display name (denormalized for faster lists)
  entityName String? // e.g. productName, branchName at time of event

  // State snapshots (whitelisted JSON shapes)
  beforeJson Json?
  afterJson  Json?
  diffJson   Json? // compact patch-style diff

  // Request context
  correlationId String?
  ip            String?
  userAgent     String?

  createdAt DateTime @default(now())

  @@index([tenantId, entityType, entityId, createdAt])
  @@index([actorUserId, createdAt])
  @@index([action, createdAt])
  @@index([correlationId])
}

/// Document chunks for RAG (Retrieval-Augmented Generation)
/// Stores embedded documentation sections for semantic search
model DocumentChunk {
  id         String @id @default(cuid())
  documentId String // File path: "docs/stock-transfers/overview.md"
  sectionId  String // Heading anchor: "## Step 1: Navigate to Transfers"
  title      String // "Creating Transfers - Step 1: Navigate"
  content    String @db.Text // Actual markdown content chunk

  /// Vector embedding (1536 dimensions for text-embedding-3-small)
  embedding Unsupported("vector(1536)")

  /// Metadata: { category: "stock-transfers", tags: ["transfer", "create"], relatedDocs: [...] }
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([documentId])
  @@map("document_chunks")
}

/// Chat conversations for AI chatbot
/// Stores conversation history per user per tenant
model ChatConversation {
  id       String  @id @default(cuid())
  userId   String
  tenantId String
  title    String? // Auto-generated from first message

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  messages ChatMessage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, tenantId])
  @@index([userId, createdAt])
}

/// Chat messages within a conversation
/// Stores individual messages (user and assistant)
model ChatMessage {
  id             String   @id @default(cuid())
  conversationId String
  role           String // 'user' | 'assistant' | 'system'
  content        Json // UIMessage parts array from Vercel AI SDK
  createdAt      DateTime @default(now())

  conversation ChatConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([conversationId, createdAt])
}

/// Chat analytics for tracking chatbot usage
/// Aggregated daily metrics per tenant
model ChatAnalytics {
  id       String   @id @default(cuid())
  tenantId String
  date     DateTime @db.Date

  // Volume metrics
  totalConversations Int @default(0) // New conversations started
  totalMessages      Int @default(0) // Total messages sent (user + assistant)
  uniqueUsers        Int @default(0) // Distinct users who chatted

  // Tool usage tracking
  toolCalls Json? // { "searchProducts": 45, "searchTransfers": 32, ... }

  // Average metrics
  avgMessagesPerConversation Float? // Average conversation length
  avgResponseTimeMs          Int? // Average assistant response time

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, date])
  @@index([tenantId, date])
}
