// Prisma uses this connection string from your .env
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Permission {
  id          String @id @default(cuid())
  /// machine key like "products:read"
  key         String @unique
  description String

  roles RolePermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Role {
  id String @id @default(cuid())

  /// null = global template role (optional); non-null = tenant-scoped role
  tenantId String?
  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  name        String // e.g. "OWNER", "Catalog Editor"
  description String?
  isSystem    Boolean @default(false) // seed defaults can mark true

  // permissions
  permissions RolePermission[]

  // reverse relation to memberships
  memberships UserTenantMembership[]

  // approval levels
  approvalLevels TransferApprovalLevel[] @relation("ApprovalLevelRequiredRole")
  approvalRecords TransferApprovalRecord[] @relation("ApprovalRecordRequiredRole")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, name]) // one role name per tenant
  @@index([tenantId])
}

/// ----- NEW: join table role<->permission -----
model RolePermission {
  roleId       String
  permissionId String

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([permissionId])
}

/// A tenant/company
model Tenant {
  id         String @id @default(cuid())
  tenantSlug String @unique
  tenantName String

  memberships UserTenantMembership[]
  products    Product[]
  branding    TenantBranding?        @relation("TenantToBranding")

  roles Role[]

  branches              Branch[]
  userBranchMemberships UserBranchMembership[]
  productStocks         ProductStock[]
  stockLots             StockLot[]
  stockLedgers          StockLedger[]
  stockTransfers        StockTransfer[]
  transferTemplates     StockTransferTemplate[]
  transferApprovalRules TransferApprovalRule[]

  // Back-relation for AuditEvent. One tenant -> many audit events.
  auditEvents AuditEvent[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum StockMovementKind {
  RECEIPT // +qty into a new (or existing) lot
  ADJUSTMENT // +/- qty (e.g., audit correction)
  CONSUMPTION // -qty to fulfill/consume (e.g., order)
  REVERSAL // reverse a prior ledger movement
}

enum StockTransferStatus {
  REQUESTED
  APPROVED
  REJECTED
  IN_TRANSIT
  PARTIALLY_RECEIVED
  COMPLETED
  CANCELLED
}

enum ApprovalRuleConditionType {
  TOTAL_QTY_THRESHOLD       // Total quantity > X
  TOTAL_VALUE_THRESHOLD     // Total value (pence) > X
  SOURCE_BRANCH             // Specific source branch
  DESTINATION_BRANCH        // Specific destination branch
  PRODUCT_CATEGORY          // Product has category X (future)
}

enum ApprovalMode {
  SEQUENTIAL  // Must approve in order
  PARALLEL    // All can approve simultaneously
  HYBRID      // Level 1 first, then 2+ parallel
}

enum ApprovalStatus {
  PENDING     // Awaiting approval
  APPROVED    // Approved
  REJECTED    // Rejected
  SKIPPED     // Not required (rule didn't match)
}

model Branch {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  branchSlug String
  branchName String
  isActive   Boolean @default(true)

  // Relations
  memberships               UserBranchMembership[]
  productStocks             ProductStock[]
  stockLots                 StockLot[]
  stockLedgers              StockLedger[]
  transfersAsSource         StockTransfer[]        @relation("TransferSource")
  transfersAsDestination    StockTransfer[]        @relation("TransferDestination")
  templateAsSource          StockTransferTemplate[] @relation("TemplateSource")
  templateAsDestination     StockTransferTemplate[] @relation("TemplateDestination")
  approvalConditions        TransferApprovalCondition[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, branchSlug]) // unique slug per tenant
  @@index([tenantId])
  @@index([tenantId, branchName])
}

model UserBranchMembership {
  id String @id @default(cuid())

  userId   String
  tenantId String
  branchId String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch Branch @relation(fields: [branchId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, branchId]) // one membership per user/branch
  @@index([tenantId])
  @@index([userId])
  @@index([branchId])
}

model ProductStock {
  id String @id @default(cuid())

  tenantId  String
  branchId  String
  productId String

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch  Branch  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  qtyOnHand    Int @default(0) // sum of lot qtyRemaining
  qtyAllocated Int @default(0) // reserved for orders (future)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, branchId, productId])
  @@index([branchId])
  @@index([productId])
}

model StockLot {
  id String @id @default(cuid())

  tenantId  String
  branchId  String
  productId String

  tenant  Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch  Branch  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  qtyReceived  Int
  qtyRemaining Int

  /// Unit cost stored in **pence** (GBP minor units)
  unitCostPence Int?
  sourceRef     String? // PO/transfer ref (future)
  receivedAt    DateTime @default(now())

  ledgerEntries StockLedger[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId, branchId, productId, receivedAt]) // FIFO scan
  @@index([branchId, productId])
}

model StockLedger {
  id String @id @default(cuid())

  tenantId  String
  branchId  String
  productId String
  lotId     String?

  tenant  Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch  Branch    @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product Product   @relation(fields: [productId], references: [id], onDelete: Restrict)
  lot     StockLot? @relation(fields: [lotId], references: [id], onDelete: SetNull)

  kind        StockMovementKind
  qtyDelta    Int // + for RECEIPT/adjust-up; - for CONSUMPTION/adjust-down
  reason      String? // free text
  actorUserId String?
  actorUser   User?             @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  occurredAt DateTime @default(now())
  createdAt  DateTime @default(now())

  @@index([tenantId, branchId, productId, occurredAt])
  @@index([kind])
}

/// A person that can belong to multiple tenants
model User {
  id                 String @id @default(cuid())
  userEmailAddress   String @unique
  userHashedPassword String

  memberships UserTenantMembership[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branchMemberships     UserBranchMembership[]
  stockLedgerEvents     StockLedger[]
  transfersRequested    StockTransfer[]        @relation("TransferRequester")
  transfersReviewed     StockTransfer[]        @relation("TransferReviewer")
  transfersShipped      StockTransfer[]        @relation("TransferShipper")
  transferTemplatesCreated StockTransferTemplate[]
  approvalLevelsAsRequired TransferApprovalLevel[] @relation("ApprovalLevelRequiredUser")
  approvalRecordsAsRequired TransferApprovalRecord[] @relation("ApprovalRecordRequiredUser")
  approvalRecordsAsApprover TransferApprovalRecord[] @relation("ApprovalRecordApprover")

  // Back-relation for AuditEvent where this user is the actor.
  auditEvents AuditEvent[]

  @@index([createdAt])
  @@index([updatedAt])
}

/// Join table: which user belongs to which tenant, with role
model UserTenantMembership {
  id       String @id @default(cuid())
  userId   String
  tenantId String

  // NEW: future source of truth
  roleId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  role   Role   @relation(fields: [roleId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, tenantId], name: "userId_tenantId")
  @@index([roleId])
}

/// A product owned by a tenant (POC scope)
model Product {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  productName       String
  productSku        String
  /// Product price stored in **pence** (GBP minor units)
  productPricePence Int

  entityVersion Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  stocks             ProductStock[]
  stockLots          StockLot[]
  stockLedgers       StockLedger[]
  transferItems      StockTransferItem[]
  transferTemplateItems StockTransferTemplateItem[]

  @@unique([tenantId, productSku])
  @@index([tenantId])
  @@index([createdAt])
  @@index([updatedAt])
}

/// Inter-branch stock transfer workflow
model StockTransfer {
  id             String @id @default(cuid())
  tenantId       String
  transferNumber String // Auto-generated (e.g., "TRF-2025-001")

  // Branches
  sourceBranchId      String
  destinationBranchId String

  // Workflow
  status StockTransferStatus @default(REQUESTED)

  // Actors
  requestedByUserId String // User who initiated request
  reviewedByUserId  String? // User who approved/rejected
  shippedByUserId   String? // User who shipped

  // Timestamps
  requestedAt DateTime  @default(now())
  reviewedAt  DateTime?
  shippedAt   DateTime?
  completedAt DateTime?

  // Notes
  requestNotes String? @db.Text
  reviewNotes  String? @db.Text // Reason for rejection

  // Reversal fields
  isReversal     Boolean @default(false) // True if this is a reversal transfer
  reversalOfId   String? // Links to original transfer (if reversal)
  reversedById   String? // Links to reversal transfer (if reversed)
  reversalReason String? @db.Text // Why reversal occurred

  // Multi-level approval
  requiresMultiLevelApproval Boolean @default(false)

  // Relations
  tenant            Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sourceBranch      Branch              @relation("TransferSource", fields: [sourceBranchId], references: [id], onDelete: Restrict)
  destinationBranch Branch              @relation("TransferDestination", fields: [destinationBranchId], references: [id], onDelete: Restrict)
  requestedByUser   User                @relation("TransferRequester", fields: [requestedByUserId], references: [id], onDelete: Restrict)
  reviewedByUser    User?               @relation("TransferReviewer", fields: [reviewedByUserId], references: [id], onDelete: SetNull)
  shippedByUser     User?               @relation("TransferShipper", fields: [shippedByUserId], references: [id], onDelete: SetNull)
  items             StockTransferItem[]
  reversalOf        StockTransfer?      @relation("TransferReversal", fields: [reversalOfId], references: [id], onDelete: SetNull)
  reversedBy        StockTransfer?      @relation("TransferReversal")
  approvalRecords   TransferApprovalRecord[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, transferNumber])
  @@unique([reversalOfId])
  @@index([tenantId, status, createdAt])
  @@index([sourceBranchId, status])
  @@index([destinationBranchId, status])
  @@index([requestedByUserId])
  @@index([reversedById])
}

/// Line items for stock transfer
model StockTransferItem {
  id         String @id @default(cuid())
  transferId String
  productId  String

  // Quantities
  qtyRequested Int  // Initial quantity requested
  qtyApproved  Int? // May differ from requested (partial approval)
  qtyShipped   Int  @default(0) // Actual qty shipped (may be less than approved)
  qtyReceived  Int  @default(0) // Actual qty received (incremental)

  // Cost tracking (populated on ship)
  lotsConsumed     Json? // Array of {lotId, qty, unitCostPence}
  avgUnitCostPence Int? // Weighted average cost of shipped items

  // Relations
  transfer StockTransfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  product  Product       @relation(fields: [productId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([transferId, productId])
  @@index([productId])
}

/// Stock transfer templates for saving common transfer configurations
model StockTransferTemplate {
  id          String @id @default(cuid())
  tenantId    String
  name        String // "Weekly Retail Restock"
  description String? @db.Text

  sourceBranchId      String
  destinationBranchId String

  createdByUserId String

  // Relations
  tenant            Tenant                        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  sourceBranch      Branch                        @relation("TemplateSource", fields: [sourceBranchId], references: [id], onDelete: Cascade)
  destinationBranch Branch                        @relation("TemplateDestination", fields: [destinationBranchId], references: [id], onDelete: Cascade)
  createdByUser     User                          @relation(fields: [createdByUserId], references: [id], onDelete: Restrict)
  items             StockTransferTemplateItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId])
  @@index([sourceBranchId])
  @@index([destinationBranchId])
  @@index([createdByUserId])
}

/// Line items for stock transfer templates
model StockTransferTemplateItem {
  id         String @id @default(cuid())
  templateId String
  productId  String
  defaultQty Int // Default quantity for this product

  // Relations
  template StockTransferTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  product  Product                @relation(fields: [productId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([templateId, productId])
  @@index([productId])
}

/// Transfer approval rules for multi-level approval workflow
model TransferApprovalRule {
  id           String        @id @default(cuid())
  tenantId     String
  name         String        // "High-Value Transfer Approval"
  description  String?       @db.Text
  isActive     Boolean       @default(true)
  approvalMode ApprovalMode  @default(SEQUENTIAL)
  priority     Int           @default(0) // Higher priority rules evaluated first

  // Relations
  tenant     Tenant                      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  conditions TransferApprovalCondition[]
  levels     TransferApprovalLevel[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tenantId, isActive])
  @@index([tenantId, priority])
}

/// Conditions that trigger an approval rule
model TransferApprovalCondition {
  id            String                      @id @default(cuid())
  ruleId        String
  conditionType ApprovalRuleConditionType
  threshold     Int?                        // For QTY/VALUE thresholds
  branchId      String?                     // For branch conditions (source or destination based on conditionType)

  // Relations
  rule   TransferApprovalRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  branch Branch?              @relation(fields: [branchId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ruleId])
  @@index([branchId])
}

/// Approval levels required by a rule
model TransferApprovalLevel {
  id             String  @id @default(cuid())
  ruleId         String
  level          Int     // 1, 2, 3, etc.
  name           String  // "Manager", "Director", "Finance"
  requiredRoleId String? // Specific role required (e.g., OWNER)
  requiredUserId String? // Specific user required (e.g., Finance Director)

  // Relations
  rule TransferApprovalRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  role Role?                @relation("ApprovalLevelRequiredRole", fields: [requiredRoleId], references: [id], onDelete: SetNull)
  user User?                @relation("ApprovalLevelRequiredUser", fields: [requiredUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([ruleId, level])
  @@index([ruleId])
  @@index([requiredRoleId])
  @@index([requiredUserId])
}

/// Records approval status for each level of a transfer
model TransferApprovalRecord {
  id               String         @id @default(cuid())
  transferId       String
  level            Int            // Which approval level this is
  levelName        String         // "Manager", "Director", etc.
  status           ApprovalStatus @default(PENDING)
  requiredRoleId   String?        // Role required for this approval
  requiredUserId   String?        // User required for this approval
  approvedByUserId String?        // Who actually approved
  approvedAt       DateTime?
  notes            String?        @db.Text

  // Relations
  transfer       StockTransfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  requiredRole   Role?         @relation("ApprovalRecordRequiredRole", fields: [requiredRoleId], references: [id], onDelete: SetNull)
  requiredUser   User?         @relation("ApprovalRecordRequiredUser", fields: [requiredUserId], references: [id], onDelete: SetNull)
  approvedByUser User?         @relation("ApprovalRecordApprover", fields: [approvedByUserId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([transferId, level])
  @@index([status])
  @@index([requiredRoleId])
  @@index([requiredUserId])
  @@index([approvedByUserId])
}

/// Stores idempotency for POST/PUT so we can replay the same result for duplicate requests
model IdempotencyRecord {
  id                 String   @id @default(cuid())
  idempotencyKey     String   @unique
  requestFingerprint String // e.g., stable hash of method+path+body+user+tenant
  storedResponseJson Json
  expiresAt          DateTime
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([expiresAt])
}

model TenantBranding {
  /// One row per tenant
  tenantId String @id
  tenant   Tenant @relation("TenantToBranding", fields: [tenantId], references: [id], onDelete: Cascade)

  /// Optional preset key (one of the frontend keys)
  presetKey String?

  /// Theme overrides exactly as your frontend builds them (JSON)
  /// { primaryColor?, primaryShade?, colors?, defaultRadius?, fontFamily? }
  overridesJson Json?

  /// Optional logo URL
  logoUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ApiRequestLog {
  id String @id @default(cuid())

  // Who
  tenantId String?
  userId   String?

  // Request
  method    String
  path      String
  routeKey  String? // e.g. "GET /api/products/:productId"
  query     String?
  ip        String?
  userAgent String?

  // Response
  statusCode    Int
  durationMs    Int
  errorCode     String?
  correlationId String?

  // Bodies (truncated/masked by middleware)
  reqBody String?
  resBody String?

  createdAt DateTime @default(now())

  @@index([tenantId, createdAt])
  @@index([userId, createdAt])
  @@index([routeKey, createdAt])
  @@index([statusCode, createdAt])
  @@index([correlationId])
}

// --- Enums ---
enum AuditEntityType {
  PRODUCT
  BRANCH
  STOCK_LOT
  STOCK_LEDGER
  PRODUCT_STOCK
  USER
  ROLE
  TENANT
  TENANT_BRANDING
  STOCK_TRANSFER
  STOCK_TRANSFER_ITEM
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  STOCK_RECEIVE
  STOCK_ADJUST
  STOCK_CONSUME
  ROLE_ASSIGN
  ROLE_REVOKE
  LOGIN
  LOGOUT
  THEME_UPDATE
  THEME_LOGO_UPDATE
  TRANSFER_REQUEST
  TRANSFER_APPROVE
  TRANSFER_REJECT
  TRANSFER_SHIP
  TRANSFER_RECEIVE
  TRANSFER_CANCEL
  TRANSFER_REVERSE
  TRANSFER_APPROVE_LEVEL // Multi-level approval submission
  APPROVAL_RULE_CREATE
  APPROVAL_RULE_UPDATE
  APPROVAL_RULE_DELETE
}

// --- Append-only audit log ---
model AuditEvent {
  id String @id @default(cuid())

  // Multi-tenant + actor
  tenantId    String
  tenant      Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  actorUserId String?
  actorUser   User?   @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  // What changed
  entityType AuditEntityType
  entityId   String
  action     AuditAction

  // Optional display name (denormalized for faster lists)
  entityName String? // e.g. productName, branchName at time of event

  // State snapshots (whitelisted JSON shapes)
  beforeJson Json?
  afterJson  Json?
  diffJson   Json? // compact patch-style diff

  // Request context
  correlationId String?
  ip            String?
  userAgent     String?

  createdAt DateTime @default(now())

  @@index([tenantId, entityType, entityId, createdAt])
  @@index([actorUserId, createdAt])
  @@index([action, createdAt])
  @@index([correlationId])
}
