// Prisma uses this connection string from your .env
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

/// Simple RBAC for later service checks
enum RoleName {
  OWNER
  ADMIN
  EDITOR
  VIEWER
}


model Permission {
  id          String            @id @default(cuid())
  /// machine key like "products:read"
  key         String            @unique
  description String

  roles       RolePermission[]

  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
}

model Role {
  id          String               @id @default(cuid())

  /// null = global template role (optional); non-null = tenant-scoped role
  tenantId    String?
  tenant      Tenant?              @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  name        String               // e.g. "OWNER", "Catalog Editor"
  description String?
  isSystem    Boolean              @default(false) // seed defaults can mark true

  // permissions
  permissions RolePermission[]

  // reverse relation to memberships
  memberships UserTenantMembership[]

  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  @@unique([tenantId, name])       // one role name per tenant
  @@index([tenantId])
}

/// ----- NEW: join table role<->permission -----
model RolePermission {
  roleId       String
  permissionId String

  role         Role        @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission  @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([permissionId])
}

/// A tenant/company
model Tenant {
  id         String @id @default(cuid())
  tenantSlug String @unique
  tenantName String

  memberships UserTenantMembership[]
  products    Product[]
  branding    TenantBranding?        @relation("TenantToBranding")

  roles       Role[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// A person that can belong to multiple tenants
model User {
  id                 String @id @default(cuid())
  userEmailAddress   String @unique
  userHashedPassword String

  memberships UserTenantMembership[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdAt])
  @@index([updatedAt])
}

/// Join table: which user belongs to which tenant, with role
model UserTenantMembership {
  id       String   @id @default(cuid())
  userId   String
  tenantId String

  // NEW: future source of truth
  roleId   String?
  role     Role?    @relation(fields: [roleId], references: [id], onDelete: SetNull)

  // OLD: keep during migration, remove later
  roleName RoleName?

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, tenantId])
  @@index([tenantId])
  @@index([userId])
  @@index([tenantId, roleName])
  @@index([roleId])
}

/// A product owned by a tenant (POC scope)
model Product {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  productName       String
  productSku        String
  productPriceCents Int

  entityVersion Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([tenantId, productSku])
  @@index([tenantId])
  @@index([createdAt])
  @@index([updatedAt])
}

/// Stores idempotency for POST/PUT so we can replay the same result for duplicate requests
model IdempotencyRecord {
  id                 String   @id @default(cuid())
  idempotencyKey     String   @unique
  requestFingerprint String // e.g., stable hash of method+path+body+user+tenant
  storedResponseJson Json
  expiresAt          DateTime
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([expiresAt])
}

model TenantBranding {
  /// One row per tenant
  tenantId String @id
  tenant   Tenant @relation("TenantToBranding", fields: [tenantId], references: [id], onDelete: Cascade)

  /// Optional preset key (one of the frontend keys)
  presetKey String?

  /// Theme overrides exactly as your frontend builds them (JSON)
  /// { primaryColor?, primaryShade?, colors?, defaultRadius?, fontFamily? }
  overridesJson Json?

  /// Optional logo URL
  logoUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
