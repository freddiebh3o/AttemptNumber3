// Prisma uses this connection string from your .env
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Permission {
  id          String            @id @default(cuid())
  /// machine key like "products:read"
  key         String            @unique
  description String

  roles       RolePermission[]

  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
}

model Role {
  id          String               @id @default(cuid())

  /// null = global template role (optional); non-null = tenant-scoped role
  tenantId    String?
  tenant      Tenant?              @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  name        String               // e.g. "OWNER", "Catalog Editor"
  description String?
  isSystem    Boolean              @default(false) // seed defaults can mark true

  // permissions
  permissions RolePermission[]

  // reverse relation to memberships
  memberships UserTenantMembership[]

  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  @@unique([tenantId, name])       // one role name per tenant
  @@index([tenantId])
}

/// ----- NEW: join table role<->permission -----
model RolePermission {
  roleId       String
  permissionId String

  role         Role        @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission  @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([permissionId])
}

/// A tenant/company
model Tenant {
  id         String @id @default(cuid())
  tenantSlug String @unique
  tenantName String

  memberships UserTenantMembership[]
  products    Product[]
  branding    TenantBranding?        @relation("TenantToBranding")

  roles       Role[]

  branches Branch[]
  userBranchMemberships UserBranchMembership[]
  productStocks ProductStock[]
  stockLots StockLot[]
  stockLedgers StockLedger[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum StockMovementKind {
  RECEIPT       // +qty into a new (or existing) lot
  ADJUSTMENT    // +/- qty (e.g., audit correction)
  CONSUMPTION   // -qty to fulfill/consume (e.g., order)
  REVERSAL      // reverse a prior ledger movement
}

model Branch {
  id         String  @id @default(cuid())
  tenantId   String
  tenant     Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  branchSlug String
  branchName String
  isActive   Boolean @default(true)

  // Relations
  memberships  UserBranchMembership[]
  productStocks ProductStock[]
  stockLots     StockLot[]
  stockLedgers  StockLedger[]

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([tenantId, branchSlug])      // unique slug per tenant
  @@index([tenantId])
  @@index([tenantId, branchName])
}

model UserBranchMembership {
  id       String @id @default(cuid())

  userId   String
  tenantId String
  branchId String

  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant   Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch   Branch  @relation(fields: [branchId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, branchId])  // one membership per user/branch
  @@index([tenantId])
  @@index([userId])
  @@index([branchId])
}

model ProductStock {
  id         String @id @default(cuid())

  tenantId   String
  branchId   String
  productId  String

  tenant     Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch     Branch  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product    Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  qtyOnHand    Int   @default(0) // sum of lot qtyRemaining
  qtyAllocated Int   @default(0) // reserved for orders (future)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([tenantId, branchId, productId])
  @@index([branchId])
  @@index([productId])
}

model StockLot {
  id         String @id @default(cuid())

  tenantId   String
  branchId   String
  productId  String

  tenant     Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch     Branch  @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product    Product @relation(fields: [productId], references: [id], onDelete: Restrict)

  qtyReceived   Int
  qtyRemaining  Int

  /// Unit cost stored in **pence** (GBP minor units)
  unitCostPence Int?
  sourceRef     String?     // PO/transfer ref (future)
  receivedAt    DateTime @default(now())

  ledgerEntries  StockLedger[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([tenantId, branchId, productId, receivedAt]) // FIFO scan
  @@index([branchId, productId])
}

model StockLedger {
  id         String @id @default(cuid())

  tenantId   String
  branchId   String
  productId  String
  lotId      String?

  tenant     Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branch     Branch    @relation(fields: [branchId], references: [id], onDelete: Cascade)
  product    Product   @relation(fields: [productId], references: [id], onDelete: Restrict)
  lot        StockLot? @relation(fields: [lotId], references: [id], onDelete: SetNull)

  kind       StockMovementKind
  qtyDelta   Int                  // + for RECEIPT/adjust-up; - for CONSUMPTION/adjust-down
  reason     String?              // free text
  actorUserId String?
  actorUser  User?     @relation(fields: [actorUserId], references: [id], onDelete: SetNull)

  occurredAt DateTime @default(now())
  createdAt  DateTime @default(now())

  @@index([tenantId, branchId, productId, occurredAt])
  @@index([kind])
}

/// A person that can belong to multiple tenants
model User {
  id                 String @id @default(cuid())
  userEmailAddress   String @unique
  userHashedPassword String

  memberships UserTenantMembership[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branchMemberships UserBranchMembership[]
  stockLedgerEvents StockLedger[]

  @@index([createdAt])
  @@index([updatedAt])
}

/// Join table: which user belongs to which tenant, with role
model UserTenantMembership {
  id       String   @id @default(cuid())
  userId   String
  tenantId String

  // NEW: future source of truth
  roleId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  role      Role     @relation(fields: [roleId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, tenantId], name: "userId_tenantId")
  @@index([roleId])
}

/// A product owned by a tenant (POC scope)
model Product {
  id       String @id @default(cuid())
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  productName        String
  productSku         String
  /// Product price stored in **pence** (GBP minor units)
  productPricePence  Int

  entityVersion Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  stocks      ProductStock[]
  stockLots   StockLot[]
  stockLedgers StockLedger[]

  @@unique([tenantId, productSku])
  @@index([tenantId])
  @@index([createdAt])
  @@index([updatedAt])
}

/// Stores idempotency for POST/PUT so we can replay the same result for duplicate requests
model IdempotencyRecord {
  id                 String   @id @default(cuid())
  idempotencyKey     String   @unique
  requestFingerprint String // e.g., stable hash of method+path+body+user+tenant
  storedResponseJson Json
  expiresAt          DateTime
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([expiresAt])
}

model TenantBranding {
  /// One row per tenant
  tenantId String @id
  tenant   Tenant @relation("TenantToBranding", fields: [tenantId], references: [id], onDelete: Cascade)

  /// Optional preset key (one of the frontend keys)
  presetKey String?

  /// Theme overrides exactly as your frontend builds them (JSON)
  /// { primaryColor?, primaryShade?, colors?, defaultRadius?, fontFamily? }
  overridesJson Json?

  /// Optional logo URL
  logoUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
